"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseDataUrl;

var _abab = require("abab");

const removeLeadingAndTrailingHTTPWhitespace = string => string.replace(/^[ \t\n\r]+/, "").replace(/[ \t\n\r]+$/, "");

const removeTrailingHTTPWhitespace = string => string.replace(/[ \t\n\r]+$/, "");

const isHTTPWhitespaceChar = char => char === " " || char === "\t" || char === "\n" || char === "\r";

const solelyContainsHTTPTokenCodePoints = string => /^[-!#$%&'*+.^_`|~A-Za-z0-9]*$/.test(string);

const soleyContainsHTTPQuotedStringTokenCodePoints = string => /^[\t\u0020-\u007E\u0080-\u00FF]*$/.test(string);

const asciiLowercase = string => string.replace(/[A-Z]/g, l => l.toLowerCase());

const collectAnHTTPQuotedString = (input, position) => {
  let value = ""; // eslint-disable-next-line no-param-reassign

  position += 1; // eslint-disable-next-line no-constant-condition

  while (true) {
    while (position < input.length && input[position] !== '"' && input[position] !== "\\") {
      value += input[position]; // eslint-disable-next-line no-param-reassign

      position += 1;
    }

    if (position >= input.length) {
      break;
    }

    const quoteOrBackslash = input[position]; // eslint-disable-next-line no-param-reassign

    position += 1;

    if (quoteOrBackslash === "\\") {
      if (position >= input.length) {
        value += "\\";
        break;
      }

      value += input[position]; // eslint-disable-next-line no-param-reassign

      position += 1;
    } else {
      break;
    }
  }

  return [value, position];
};

function isASCIIHex(c) {
  return c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;
}

function percentDecodeBytes(input) {
  const output = new Uint8Array(input.byteLength);
  let outputIndex = 0;

  for (let i = 0; i < input.byteLength; ++i) {
    const byte = input[i];

    if (byte !== 0x25) {
      output[outputIndex] = byte;
    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {
      output[outputIndex] = byte;
    } else {
      output[outputIndex] = parseInt(String.